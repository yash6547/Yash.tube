<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Image ‚Üí MCQ Quiz Maker (Camera + Upload + Crop + OCR + Attempt)</title>

<!-- CropperJS CSS -->
<link href="https://cdn.jsdelivr.net/npm/cropperjs@1.5.13/dist/cropper.min.css" rel="stylesheet"/>

<style>
  :root{
    --bg:#0f1724; --card:#0b1220; --accent:#06b6d4; --muted:#94a3b8; --success:#10b981;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#071029 0%, #051022 100%);font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  .wrap{max-width:1100px;margin:18px auto;padding:14px;color:#e6eef6}
  header{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px}
  h1{font-size:18px;margin:0}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  button, .btn{background:var(--accent);color:#012; border:0;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600}
  .ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
  .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:14px;border-radius:12px;margin-bottom:12px;border:1px solid rgba(255,255,255,0.03)}
  .center{text-align:center}
  video{width:100%;height:auto;border-radius:10px; background:#000}
  #cameraContainer{position:relative}
  .camera-full{position:fixed;top:0;left:0;right:0;bottom:0;z-index:9999;background:rgba(0,0,0,0.95);display:flex;flex-direction:column;align-items:center;justify-content:center;padding:12px}
  .camera-top{position:absolute;top:12px;left:12px;right:12px;display:flex;justify-content:space-between;z-index:10000}
  .icon-btn{background:rgba(255,255,255,0.06);color:#e6eef6;border-radius:10px;padding:10px 12px;border:1px solid rgba(255,255,255,0.02);cursor:pointer}
  .capture-btn{background:var(--success);color:#012;padding:14px 18px;border-radius:999px;border:0;font-weight:800;box-shadow:0 8px 24px rgba(3,105,78,0.14)}
  .small{font-size:13px;color:var(--muted)}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .col{display:flex;flex-direction:column;gap:8px}
  .hidden{display:none!important}
  img.preview{max-width:100%;border-radius:10px}
  /* Cropper area */
  .crop-area{max-width:720px;max-height:80vh;overflow:hidden;background:#000;border-radius:10px;margin:0 auto}
  .editor-controls{display:flex;gap:8px;justify-content:center;margin-top:8px}
  input[type="number"]{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
  .question-card{background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.02);margin-bottom:8px}
  label.inline{display:flex;gap:8px;align-items:center}
  .controls-bottom{display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end}
  .badge{background:rgba(255,255,255,0.03);padding:6px 10px;border-radius:999px;font-weight:700;color:var(--muted)}
  textarea{min-height:80px;width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:inherit}
  .muted{color:var(--muted)}
  .resultbox{padding:12px;border-radius:12px;background:linear-gradient(180deg, rgba(16,185,129,0.06), rgba(6,182,212,0.02));text-align:center;font-weight:700}
  .flex-between{display:flex;justify-content:space-between;align-items:center}
  .option-input{width:calc(100% - 90px);padding:6px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
  .small-ghost{background:transparent;border:1px dashed rgba(255,255,255,0.03);padding:6px;border-radius:6px;color:var(--muted)}
  footer{margin-top:24px;text-align:center;color:var(--muted);font-size:13px}
  @media(max-width:720px){ .wrap{padding:8px} .controls-bottom{justify-content:center} }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div>
      <h1>üì∏ Image ‚Üí MCQ Quiz Maker</h1>
      <div class="small muted">Camera / Upload ‚Üí Crop & Rotate ‚Üí OCR ‚Üí Auto-parse ‚Üí Edit ‚Üí Attempt ‚Üí Export</div>
    </div>
    <div class="controls">
      <button id="startBtn" class="btn">Start (Camera / Upload)</button>
      <button id="importBtn" class="ghost">Import JSON</button>
      <button id="exportBtn" class="ghost">Export Quiz JSON</button>
    </div>
  </header>

  <!-- Step: Choice Modal -->
  <div id="choicePanel" class="panel center">
    <div style="font-weight:700;margin-bottom:8px">Choose Image Source</div>
    <div class="row" style="justify-content:center">
      <button id="chooseCamera" class="btn">üì∑ Use Camera</button>
      <button id="chooseUpload" class="ghost" style="color:var(--muted)">üìÅ Upload File</button>
      <input id="fileInput" type="file" accept="image/*" class="hidden" />
    </div>
    <div class="small muted" style="margin-top:8px">Note: Camera will open only when you choose "Use Camera".</div>
  </div>

  <!-- Camera Fullscreen Modal -->
  <div id="cameraModal" class="camera-full hidden" aria-hidden="true">
    <div class="camera-top">
      <div class="row">
        <button id="closeCam" class="icon-btn">‚úñ Close</button>
        <div class="badge small muted">Camera Mode</div>
      </div>
      <div class="row">
        <button id="flipCam" class="icon-btn">üîÅ Flip</button>
        <button id="toggleTorch" class="icon-btn">üî¶ Torch</button>
      </div>
    </div>

    <div style="width:100%;max-width:900px;">
      <div id="cameraContainer" style="position:relative">
        <video id="video" autoplay playsinline></video>
        <canvas id="camCanvas" class="hidden"></canvas>
      </div>
      <div style="height:12px"></div>
      <div class="row" style="justify-content:center;align-items:center">
        <button id="captureBtn" class="capture-btn">‚óè Capture</button>
      </div>
      <div style="height:18px"></div>
      <div class="small muted center">Tip: keep phone parallel to book page, good light for better OCR.</div>
    </div>
  </div>

  <!-- Image preview + confirm -->
  <div id="previewPanel" class="panel hidden center">
    <div style="font-weight:700;margin-bottom:8px">Preview</div>
    <img id="previewImg" class="preview" alt="preview" />
    <div style="height:10px"></div>
    <div class="row" style="justify-content:center">
      <button id="confirmImage" class="btn">‚úÖ Use this</button>
      <button id="rejectImage" class="ghost">‚ùå Retake / Re-upload</button>
    </div>
  </div>

  <!-- Crop + Rotate Panel -->
  <div id="cropPanel" class="panel hidden">
    <div class="flex-between">
      <div style="font-weight:700">Crop & Rotate</div>
      <div class="small muted">Use crop to isolate question area. Rotate if photo inverted.</div>
    </div>
    <div style="height:12px"></div>
    <div class="crop-area">
      <img id="cropImage" src="" alt="to crop" style="max-width:100%;display:block" />
    </div>
    <div class="editor-controls">
      <button id="rotateLeft" class="icon-btn">‚ü≤ Rotate Left</button>
      <button id="rotateRight" class="icon-btn">‚ü≥ Rotate Right</button>
      <button id="flipHorizontal" class="icon-btn">‚Üî Flip</button>
      <button id="applyCrop" class="btn">Apply Crop</button>
      <button id="cancelCrop" class="ghost">Cancel</button>
    </div>
  </div>

  <!-- OCR progress + Parsed text (hidden until done) -->
  <div id="ocrPanel" class="panel hidden">
    <div class="flex-between">
      <div style="font-weight:700">OCR & Parse</div>
      <div class="small muted" id="ocrStatus">Waiting...</div>
    </div>
    <div style="height:8px"></div>
    <div class="row">
      <div style="flex:1">
        <div style="font-size:13px;margin-bottom:6px" class="muted">Detected text (editable):</div>
        <textarea id="detectedText" class="muted"></textarea>
      </div>
      <div style="width:280px;margin-left:8px">
        <div style="font-weight:700">Parsing Options</div>
        <div style="height:8px"></div>
        <label class="inline"><input id="parseNumbers" type="checkbox" checked> Expect numbered questions (1., 2.)</label>
        <label class="inline"><input id="parseLetters" type="checkbox" checked> Expect lettered options (A., B.)</label>
        <div style="height:10px"></div>
        <button id="parseBtn" class="btn">Parse to Quiz</button>
      </div>
    </div>
  </div>

  <!-- Quiz Editor -->
  <div id="editorPanel" class="panel hidden">
    <div class="flex-between">
      <div style="font-weight:700">Quiz Editor</div>
      <div class="row">
        <div class="badge small muted">Questions: <span id="qcount">0</span></div>
        <button id="autoMarkBtn" class="ghost small-ghost">Auto mark first option as correct (temp)</button>
      </div>
    </div>
    <div id="questionsWrap" style="margin-top:10px"></div>

    <div style="height:8px"></div>
    <div class="row" style="justify-content:space-between;align-items:center">
      <div class="col" style="max-width:420px">
        <div style="font-weight:700">Scoring</div>
        <div class="row">
          <label>Marks / question: <input id="marksPerQ" type="number" value="1" min="0" step="0.25"></label>
          <label>Negative per wrong: <input id="negPerQ" type="number" value="0" min="0" step="0.25"></label>
        </div>
      </div>

      <div class="controls-bottom">
        <button id="attemptModeBtn" class="btn">Attempt Quiz</button>
        <button id="clearQuizBtn" class="ghost">Clear Quiz</button>
      </div>
    </div>
  </div>

  <!-- Attempt Panel -->
  <div id="attemptPanel" class="panel hidden">
    <div class="flex-between"><div style="font-weight:700">Attempt Quiz</div><div class="small muted">Answer all questions and Submit</div></div>
    <div id="attemptQuestions" style="margin-top:10px"></div>
    <div style="height:10px"></div>
    <div class="row" style="justify-content:space-between;align-items:center">
      <div class="small muted">Marks: <span id="marksSummary">0</span></div>
      <div class="row">
        <button id="submitAttempt" class="btn">Submit</button>
        <button id="backToEdit" class="ghost">Back to Edit</button>
      </div>
    </div>
    <div style="height:10px"></div>
    <div id="attemptResult" class="hidden"></div>
  </div>

  <footer>Made for you ‚Äî copy, test, and improve. If kuch aur add karna ho to bol de.</footer>
</div>

<!-- Libraries: CropperJS, Tesseract -->
<script src="https://cdn.jsdelivr.net/npm/cropperjs@1.5.13/dist/cropper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.4.0/dist/tesseract.min.js"></script>

<script>
/*
  Full app JS
  Flow:
   - startBtn opens choicePanel
   - chooseCamera -> open cameraModal (full screen)
   - capture -> show previewPanel
   - confirm -> open cropPanel (CropperJS)
   - applyCrop -> run OCR (Tesseract)
   - parse text -> build quiz editor
   - user edits, sets correct answers, sets marks
   - attempt mode -> user attempts -> submit -> score shows (positive/negative)
   - export/import JSON available
*/

const startBtn = document.getElementById('startBtn');
const choicePanel = document.getElementById('choicePanel');
const chooseCamera = document.getElementById('chooseCamera');
const chooseUpload = document.getElementById('chooseUpload');
const fileInput = document.getElementById('fileInput');
const cameraModal = document.getElementById('cameraModal');
const video = document.getElementById('video');
const captureBtn = document.getElementById('captureBtn');
const closeCam = document.getElementById('closeCam');
const flipCam = document.getElementById('flipCam');
const toggleTorch = document.getElementById('toggleTorch');
const camCanvas = document.getElementById('camCanvas');

const previewPanel = document.getElementById('previewPanel');
const previewImg = document.getElementById('previewImg');
const confirmImage = document.getElementById('confirmImage');
const rejectImage = document.getElementById('rejectImage');

const cropPanel = document.getElementById('cropPanel');
const cropImage = document.getElementById('cropImage');
const rotateLeft = document.getElementById('rotateLeft');
const rotateRight = document.getElementById('rotateRight');
const flipHorizontal = document.getElementById('flipHorizontal');
const applyCrop = document.getElementById('applyCrop');
const cancelCrop = document.getElementById('cancelCrop');

const ocrPanel = document.getElementById('ocrPanel');
const ocrStatus = document.getElementById('ocrStatus');
const detectedText = document.getElementById('detectedText');
const parseBtn = document.getElementById('parseBtn');
const parseNumbers = document.getElementById('parseNumbers');
const parseLetters = document.getElementById('parseLetters');

const editorPanel = document.getElementById('editorPanel');
const questionsWrap = document.getElementById('questionsWrap');
const qcount = document.getElementById('qcount');
const marksPerQ = document.getElementById('marksPerQ');
const negPerQ = document.getElementById('negPerQ');
const attemptModeBtn = document.getElementById('attemptModeBtn');
const clearQuizBtn = document.getElementById('clearQuizBtn');
const autoMarkBtn = document.getElementById('autoMarkBtn');

const attemptPanel = document.getElementById('attemptPanel');
const attemptQuestions = document.getElementById('attemptQuestions');
const submitAttempt = document.getElementById('submitAttempt');
const backToEdit = document.getElementById('backToEdit');
const marksSummary = document.getElementById('marksSummary');
const attemptResult = document.getElementById('attemptResult');

const exportBtn = document.getElementById('exportBtn');
const importBtn = document.getElementById('importBtn');

let cropper = null;
let currentStream = null;
let usingFront = false;
let torchOn = false;

let workingImageDataURL = null; // final cropped image to OCR
let quizData = { title: "Generated Quiz", questions: [] };

// --- start flow ---
startBtn.addEventListener('click', ()=> {
  choicePanel.scrollIntoView({behavior:'smooth'});
});

// Camera handling
async function openCamera(){
  cameraModal.classList.remove('hidden');
  // preferred constraints
  const constraints = {
    video: { facingMode: usingFront ? 'user' : 'environment', width: { ideal: 1280 }, height: { ideal: 720 }},
    audio: false
  };
  try {
    if (currentStream) {
      currentStream.getTracks().forEach(t=>t.stop());
      currentStream = null;
    }
    currentStream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = currentStream;
    await video.play();
  } catch(err) {
    alert("Camera access error: " + err.message);
    cameraModal.classList.add('hidden');
  }
}

chooseCamera.addEventListener('click', async ()=>{
  await openCamera();
});

closeCam.addEventListener('click', ()=>{
  cameraModal.classList.add('hidden');
  if (currentStream) {
    currentStream.getTracks().forEach(t=>t.stop());
    currentStream = null;
  }
});

flipCam.addEventListener('click', async ()=>{
  usingFront = !usingFront;
  if (currentStream) currentStream.getTracks().forEach(t=>t.stop());
  await openCamera();
});

// Torch toggle (best-effort, may not work on all devices)
toggleTorch.addEventListener('click', async ()=>{
  if (!currentStream) return;
  const [track] = currentStream.getVideoTracks();
  const capabilities = track.getCapabilities();
  if (!capabilities.torch) {
    alert("Torch not supported on this device.");
    return;
  }
  try {
    torchOn = !torchOn;
    await track.applyConstraints({ advanced: [{ torch: torchOn }]});
  } catch(e) { console.warn(e); alert("Torch control failed."); }
});

// capture
captureBtn.addEventListener('click', ()=>{
  // draw video on canvas
  camCanvas.width = video.videoWidth;
  camCanvas.height = video.videoHeight;
  const ctx = camCanvas.getContext('2d');
  ctx.drawImage(video, 0, 0, camCanvas.width, camCanvas.height);
  const dataUrl = camCanvas.toDataURL('image/jpeg', 0.95);
  previewImg.src = dataUrl;
  // stop camera
  if (currentStream) { currentStream.getTracks().forEach(t=>t.stop()); currentStream=null; }
  cameraModal.classList.add('hidden');
  previewPanel.classList.remove('hidden');
});

// Upload handling
chooseUpload.addEventListener('click', ()=> fileInput.click());
fileInput.addEventListener('change', (e)=>{
  const f = e.target.files[0];
  if (!f) return;
  const reader = new FileReader();
  reader.onload = ()=> {
    previewImg.src = reader.result;
    previewPanel.classList.remove('hidden');
  };
  reader.readAsDataURL(f);
});

// preview confirm or reject
rejectImage.addEventListener('click', ()=>{
  previewPanel.classList.add('hidden');
  // reset file input
  fileInput.value = "";
});

confirmImage.addEventListener('click', ()=>{
  // move to cropper
  const src = previewImg.src;
  if (!src) return alert('No image found');
  previewPanel.classList.add('hidden');
  cropImage.src = src;
  cropPanel.classList.remove('hidden');
  // init cropper
  setTimeout(()=> {
    if (cropper) cropper.destroy();
    cropper = new Cropper(cropImage, {
      viewMode: 1,
      autoCropArea: 0.9,
      movable: true,
      zoomable: true,
      rotatable: true,
      responsive: true,
      background: false
    });
  }, 200);
});

// cropper controls
rotateLeft.addEventListener('click', ()=> cropper && cropper.rotate(-90));
rotateRight.addEventListener('click', ()=> cropper && cropper.rotate(90));
flipHorizontal.addEventListener('click', ()=> {
  if (!cropper) return;
  const scaleX = cropper.getData().scaleX || 1;
  cropper.scaleX(-scaleX);
});

cancelCrop.addEventListener('click', ()=> {
  if (cropper) { cropper.destroy(); cropper=null; }
  cropPanel.classList.add('hidden');
  previewPanel.classList.remove('hidden');
});

// apply crop -> run OCR
applyCrop.addEventListener('click', async ()=> {
  if (!cropper) return;
  const canvas = cropper.getCroppedCanvas({ imageSmoothingQuality: 'high' , maxWidth: 2000, maxHeight:2000});
  const dataUrl = canvas.toDataURL('image/jpeg', 0.95);
  workingImageDataURL = dataUrl;
  // destroy cropper
  cropper.destroy(); cropper=null;
  cropPanel.classList.add('hidden');
  // go to OCR panel
  ocrPanel.classList.remove('hidden');
  ocrStatus.textContent = "Running OCR (Tesseract)...";
  detectedText.value = "";
  // Run Tesseract
  try {
    const worker = Tesseract.createWorker({
      logger: m => {
        // show progress
        if (m && m.status) {
          const pct = m.progress ? Math.round(m.progress*100) : '';
          ocrStatus.textContent = `${m.status} ${pct}%`;
        }
      }
    });
    await worker.load();
    await worker.loadLanguage('eng');
    await worker.initialize('eng');
    const { data: { text } } = await worker.recognize(dataUrl);
    detectedText.value = text.trim();
    ocrStatus.textContent = "OCR complete. Edit text if needed, then Parse.";
    await worker.terminate();
  } catch (e) {
    ocrStatus.textContent = "OCR failed: " + e.message;
  }
});

// parse button -> parse detectedText to questions
function simpleParse(text) {
  // Heuristic parser:
  // 1) Split lines, merge lines that are continuous
  // 2) Detect question starts by numbers like "1." or by lines ending with '?'
  // 3) Detect options by starting with A./A) or single letter lines "A" then text
  // 4) Group accordingly; fallback: chunk by '?' then next lines as options
  const lines = text.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
  const qs = [];
  let curr = null;

  const qNumRegex = /^(\d{1,3})[\.\)]\s*(.+)/; // "1. Question"
  const optRegex = /^([A-D])[\.\)]\s*(.+)/i;   // "A. option"
  const optInlineRegex = /\s([A-D])[\.\)]\s/;  // inline check

  for (let i=0;i<lines.length;i++){
    const L = lines[i];
    let m = L.match(qNumRegex);
    if (m) {
      if (curr) qs.push(curr);
      curr = { qnum: m[1], qtext: m[2], opts: [] };
      continue;
    }
    // option detection
    let mo = L.match(optRegex);
    if (mo && curr) {
      curr.opts.push({ label: mo[1].toUpperCase(), text: mo[2] });
      continue;
    }
    // if line contains "A. " inline, try to split
    if (optInlineRegex.test(L) && curr && !/^\d/.test(L)) {
      // split using A./B. markers
      // naive split by regexp
      const parts = L.split(/(?=[A-D][\.\)])/i);
      parts.forEach(p => {
        const m2 = p.match(optRegex);
        if (m2) curr.opts.push({ label: m2[1].toUpperCase(), text: m2[2].trim() });
      });
      continue;
    }
    // if line ends with ?, treat as new question if not in curr
    if (L.endsWith('?') && !curr) {
      curr = { qnum: null, qtext: L, opts: [] };
      continue;
    }
    // if curr exists but no options yet -> treat as continuation of question
    if (curr && !curr.opts.length && !optRegex.test(L)) {
      curr.qtext += ' ' + L;
      continue;
    }
    // if curr exists and options exist but line doesn't match option -> append to last option text
    if (curr && curr.opts.length && !optRegex.test(L)) {
      curr.opts[curr.opts.length-1].text += ' ' + L;
      continue;
    }
    // fallback: if line contains '?' start new question
    if (L.includes('?')) {
      if (curr) qs.push(curr);
      curr = { qnum: null, qtext: L, opts: [] };
      continue;
    }
    // otherwise skip
  }
  if (curr) qs.push(curr);

  // Cleanup: ensure options labeled A,B,C.. if unlabeled
  qs.forEach(q=>{
    if (q.opts.length && !q.opts[0].label) {
      q.opts = q.opts.map((o,idx)=>({ label: String.fromCharCode(65+idx), text: o.text || o }));
    }
  });

  // If parser found zero questions, fallback: split by '?' then parse options below each
  if (!qs.length) {
    const chunks = text.split('?').map(s=>s.trim()).filter(Boolean);
    chunks.forEach((ch,idx)=>{
      const post = ch + (idx < chunks.length ? '?' : '');
      // try to find options lines following this chunk in original text
      const opts = [];
      // naive: look for lines starting with A./B.
      // we'll just leave opts empty and allow user to add
      qs.push({ qnum: idx+1, qtext: post, opts });
    });
  }

  // map to normalized structure
  return qs.map((q,i)=>({
    id: 'q'+(i+1),
    number: q.qnum || (i+1),
    text: q.qtext,
    options: q.opts.length ? q.opts.map(o=>({ label:o.label, text:o.text, id: Math.random().toString(36).slice(2,8)})) : [],
    correct: null
  }));
}

parseBtn.addEventListener('click', ()=> {
  const txt = detectedText.value.trim();
  if (!txt) return alert('Detected text empty. Please edit or re-crop image.');
  const parsed = simpleParse(txt);
  quizData.title = "Generated Quiz";
  quizData.questions = parsed;
  // ensure at least 2-3 options for each question: if empty, add placeholders
  quizData.questions.forEach(q=>{
    if (!q.options.length) {
      q.options = [
        { label:'A', text:'Option A (edit)', id:Math.random().toString(36).slice(2,8) },
        { label:'B', text:'Option B (edit)', id:Math.random().toString(36).slice(2,8) },
        { label:'C', text:'Option C (edit)', id:Math.random().toString(36).slice(2,8) }
      ];
    }
  });
  ocrPanel.classList.add('hidden');
  renderEditor();
});

// Render Editor UI
function renderEditor() {
  editorPanel.classList.remove('hidden');
  questionsWrap.innerHTML = '';
  qcount.textContent = quizData.questions.length;
  quizData.questions.forEach((q,qi)=>{
    const div = document.createElement('div');
    div.className = 'question-card';
    div.dataset.qid = q.id;
    div.innerHTML = `
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div style="font-weight:700">Q${qi+1}. <span class="muted small">${q.number ? '(#'+q.number+')' : ''}</span></div>
        <div class="row">
          <button class="ghost small-ghost editQ">Edit Q</button>
          <button class="ghost small-ghost addOpt">+Opt</button>
          <button class="ghost small-ghost delQ">Delete</button>
        </div>
      </div>
      <div style="margin-top:8px">
        <textarea class="qtext">${escapeHtml(q.text)}</textarea>
      </div>
      <div style="margin-top:8px" class="optsWrap"></div>
      <div style="margin-top:8px" class="qmeta small muted">Correct: <span class="corr">${q.correct || 'Not set'}</span></div>
    `;
    questionsWrap.appendChild(div);

    const optsWrap = div.querySelector('.optsWrap');
    function renderOptions() {
      optsWrap.innerHTML = '';
      q.options.forEach((opt,oi)=>{
        const optDiv = document.createElement('div');
        optDiv.style.display = 'flex';
        optDiv.style.gap = '8px';
        optDiv.style.marginTop = '6px';
        optDiv.innerHTML = `
          <input type="radio" name="corr_${q.id}" ${q.correct===opt.label ? 'checked': ''} value="${opt.label}">
          <input class="option-input optText" data-oid="${opt.id}" value="${escapeHtml(opt.text)}">
          <input class="small-ghost optLabel" style="width:60px" value="${opt.label}">
          <button class="ghost small-ghost delOpt">Del</button>
        `;
        optsWrap.appendChild(optDiv);

        // events
        optDiv.querySelector('input[type=radio]').addEventListener('change', (e)=>{
          q.correct = opt.label;
          div.querySelector('.corr').textContent = q.correct;
        });
        optDiv.querySelector('.delOpt').addEventListener('click', ()=>{
          q.options = q.options.filter(o=>o.id !== opt.id);
          renderOptions();
        });
        optDiv.querySelector('.optText').addEventListener('input', (ev)=>{
          opt.text = ev.target.value;
        });
        optDiv.querySelector('.optLabel').addEventListener('input', (ev)=>{
          opt.label = ev.target.value.toUpperCase();
          renderOptions(); // refresh to keep labels consistent
        });
      });
    }
    renderOptions();

    // edit q text
    div.querySelector('.qtext').addEventListener('input', (e)=> q.text = e.target.value);

    // add option
    div.querySelector('.addOpt').addEventListener('click', ()=>{
      const nextLabel = String.fromCharCode(65 + q.options.length);
      q.options.push({ label: nextLabel, text: 'New option', id: Math.random().toString(36).slice(2,8) });
      renderOptions();
    });

    // delete question
    div.querySelector('.delQ').addEventListener('click', ()=>{
      if (!confirm('Delete this question?')) return;
      quizData.questions = quizData.questions.filter(x=>x.id!==q.id);
      renderEditor();
    });

    // edit open in prompt
    div.querySelector('.editQ').addEventListener('click', ()=>{
      const newq = prompt('Edit question text', q.text);
      if (newq != null) { q.text = newq; div.querySelector('.qtext').value = q.text; }
    });
  });
}

// helper escape
function escapeHtml(s){ return (s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

// clear quiz
clearQuizBtn.addEventListener('click', ()=>{
  if (!confirm('Clear the generated quiz?')) return;
  quizData.questions = [];
  editorPanel.classList.add('hidden');
});

// auto mark first option
autoMarkBtn.addEventListener('click', ()=>{
  quizData.questions.forEach(q=>{ if (q.options && q.options[0]) q.correct = q.options[0].label; });
  renderEditor();
});

// Attempt mode
attemptModeBtn.addEventListener('click', ()=>{
  if (!quizData.questions.length) return alert('No questions in quiz.');
  editorPanel.classList.add('hidden');
  attemptPanel.classList.remove('hidden');
  renderAttempt();
});

function renderAttempt(){
  attemptQuestions.innerHTML = '';
  marksSummary.textContent = `${marksPerQ.value} / q, -${negPerQ.value} per wrong`;
  quizData.questions.forEach((q,idx)=>{
    const div = document.createElement('div');
    div.className = 'question-card';
    div.innerHTML = `<div style="font-weight:700">Q${idx+1}. ${escapeHtml(q.text)}</div>
      <div style="margin-top:6px" class="optsArea"></div>`;
    attemptQuestions.appendChild(div);
    const optsArea = div.querySelector('.optsArea');
    q.options.forEach(opt=>{
      const lab = document.createElement('label');
      lab.className = 'inline';
      lab.style.marginTop = '6px';
      lab.innerHTML = `<input type="radio" name="ans_${idx}" value="${opt.label}"> <div style="margin-left:6px">${escapeHtml(opt.label)}. ${escapeHtml(opt.text)}</div>`;
      optsArea.appendChild(lab);
    });
  });
}

// submit attempt
submitAttempt.addEventListener('click', ()=>{
  const totalQ = quizData.questions.length;
  let score = 0;
  let correctCount = 0, wrongCount = 0, unattempted = 0;
  quizData.questions.forEach((q,idx)=>{
    const sel = document.querySelector(`input[name="ans_${idx}"]:checked`);
    if (!sel) { unattempted++; return; }
    const chosen = sel.value;
    if (q.correct && chosen === q.correct) {
      correctCount++;
      score += parseFloat(marksPerQ.value || 0);
    } else {
      wrongCount++;
      score -= parseFloat(negPerQ.value || 0);
    }
  });
  attemptResult.classList.remove('hidden');
  attemptResult.className = 'resultbox';
  attemptResult.innerHTML = `
    Score: ${score} <br>
    Correct: ${correctCount} | Wrong: ${wrongCount} | Unattempted: ${unattempted} <br>
    Total Questions: ${totalQ}
  `;
});

// back to edit
backToEdit.addEventListener('click', ()=>{
  attemptPanel.classList.add('hidden');
  editorPanel.classList.remove('hidden');
  attemptResult.classList.add('hidden');
});

// EXPORT / IMPORT
exportBtn.addEventListener('click', ()=>{
  // build export object
  const exportObj = {
    meta: { title: quizData.title, marksPerQ: marksPerQ.value, negPerQ: negPerQ.value, exportedAt: (new Date()).toISOString()},
    quiz: quizData
  };
  const blob = new Blob([JSON.stringify(exportObj, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'quiz_export.json';
  a.click();
  URL.revokeObjectURL(url);
});

importBtn.addEventListener('click', ()=>{
  const input = document.createElement('input');
  input.type='file';
  input.accept='application/json';
  input.onchange = async (e)=>{
    const f = e.target.files[0];
    if (!f) return;
    const txt = await f.text();
    try {
      const obj = JSON.parse(txt);
      if (obj.quiz) {
        quizData = obj.quiz;
        // set marks if present
        if (obj.meta) {
          marksPerQ.value = obj.meta.marksPerQ || marksPerQ.value;
          negPerQ.value = obj.meta.negPerQ || negPerQ.value;
        }
        renderEditor();
        alert('Quiz imported.');
      } else {
        alert('Invalid quiz file.');
      }
    } catch(e) { alert('Import error: ' + e.message); }
  };
  input.click();
});

// initial bindings for choicePanel buttons
// show/hide choice panel when start
document.getElementById('startBtn').addEventListener('click', ()=>{
  // focus: display choice panel (already visible) -> scroll
  choicePanel.scrollIntoView({behavior:'smooth'});
});

// small usability: pressing Escape cancels camera / crop
document.addEventListener('keydown', (e)=>{
  if (e.key === 'Escape') {
    if (!cameraModal.classList.contains('hidden')) { closeCam.click(); }
    if (!cropPanel.classList.contains('hidden')) { cancelCrop.click(); }
  }
});

</script>
</body>
</html>
