<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Image → MCQ Quiz (Prototype)</title>
  <style>
    body{font-family: Arial, Helvetica, sans-serif; max-width:1000px; margin:20px auto; padding:10px;}
    h1{font-size:20px;margin-bottom:8px}
    #controls{display:flex;gap:10px;align-items:center;margin-bottom:12px}
    canvas{display:none}
    .question{border:1px solid #ddd;padding:10px;margin-bottom:8px;border-radius:6px}
    .opts{margin-top:6px}
    .opts label{display:block;margin:4px 0}
    .small{font-size:13px;color:#555}
    button{padding:8px 10px;border-radius:6px;border:0;background:#007bff;color:#fff;cursor:pointer}
    button.gray{background:#6c757d}
    pre{background:#f6f6f6;padding:10px;border-radius:6px;overflow:auto}
  </style>
</head>
<body>
  <h1>Image → MCQ Quiz (Prototype)</h1>
  <div id="controls">
    <input id="file" type="file" accept="image/*"/>
    <button id="run">Detect & Make Quiz</button>
    <button id="export" class="gray">Export JSON</button>
    <span class="small">Tip: clear, well-lit photos with printed text give best results.</span>
  </div>

  <div id="status" class="small"></div>
  <canvas id="cv"></canvas>

  <div id="quiz"></div>

  <h3>Parsed text (OCR output)</h3>
  <pre id="ocrtext"></pre>

<script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/tesseract.min.js"></script>
<script>
const fileIn = document.getElementById('file');
const runBtn = document.getElementById('run');
const exportBtn = document.getElementById('export');
const statusEl = document.getElementById('status');
const ocrtextPre = document.getElementById('ocrtext');
const quizDiv = document.getElementById('quiz');
const canvas = document.getElementById('cv');
const ctx = canvas.getContext('2d');

function preprocessImage(img) {
  // draw image to canvas and apply simple preprocessing: resize, grayscale, threshold
  const maxW = 1600;
  let w = img.width, h = img.height;
  if (w > maxW) { h = Math.round(h * maxW / w); w = maxW; }
  canvas.width = w; canvas.height = h;
  ctx.drawImage(img, 0, 0, w, h);

  // basic grayscale + simple adaptive-ish threshold
  const imgd = ctx.getImageData(0,0,w,h);
  const d = imgd.data;
  for (let i=0;i<d.length;i+=4) {
    const r=d[i], g=d[i+1], b=d[i+2];
    const gray = 0.299*r + 0.587*g + 0.114*b;
    d[i]=d[i+1]=d[i+2]=gray;
  }
  // simple contrast stretch
  let min=255,max=0;
  for (let i=0;i<d.length;i+=4){ if(d[i]<min)min=d[i]; if(d[i]>max)max=d[i]; }
  const scale = 255/(max-min||1);
  for (let i=0;i<d.length;i+=4){
    let v = Math.round((d[i]-min)*scale);
    d[i]=d[i+1]=d[i+2]=v;
  }
  ctx.putImageData(imgd,0,0);
  // optional: apply global threshold to boost text
  const thresh = 160;
  const imgd2 = ctx.getImageData(0,0,w,h);
  const d2 = imgd2.data;
  for (let i=0;i<d2.length;i+=4){
    const v = d2[i] > thresh ? 255 : 0;
    d2[i]=d2[i+1]=d2[i+2]=v;
  }
  ctx.putImageData(imgd2,0,0);
}

function simpleParse(text) {
  // Heuristics-based parser: finds numbered questions and options (A,B,C,D...)
  const lines = text.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
  const qs = [];
  let curr = null;

  // regex patterns
  const qStart = /^\s*(\d{1,3})[\.\)]\s*(.+)/; // "1. Question..." or "1) Question..."
  const optStart = /^\s*([A-D]|[A-D]\.|[A-D]\)|\([A-D]\))\s*(.+)/i; // A. option, (A) option
  const optOnlyLetter = /^\s*([A-D])\s*[\.\)]?\s*(.+)/i;

  for (let i=0;i<lines.length;i++){
    const L = lines[i];

    let m = L.match(qStart);
    if (m) {
      // new question
      if (curr) qs.push(curr);
      curr = {num: m[1], q: m[2].trim(), opts: []};
      continue;
    }
    // if line ends with '?' but not matched as numbered, treat as question (fallback)
    if (!curr && L.endsWith('?')) {
      curr = {num: null, q: L, opts: []}; continue;
    }
    // option detection
    let mo = L.match(optStart) || L.match(optOnlyLetter);
    if (mo && curr) {
      // normalize label A/B/C...
      let label = mo[1].replace(/\W/g,'').toUpperCase();
      curr.opts.push({label, text: mo[2].trim()});
      continue;
    }
    // sometimes options are on separate lines without letter, if previous line was option header:
    if (curr && curr.opts.length && /^[^\dA-Z]/.test(L)) {
      // append as continuation to last option
      curr.opts[curr.opts.length-1].text += ' ' + L;
      continue;
    }
    // fallback: if curr exists but line looks like a question continuation, append
    if (curr && !curr.opts.length && !L.match(/^[A-D]\b/i)) {
      curr.q += ' ' + L;
      continue;
    }
  }
  if (curr) qs.push(curr);
  // cleanup: if opts labels inconsistent, auto-label A,B,C...
  qs.forEach(q=>{
    if (q.opts.length && !q.opts[0].label) {
      q.opts = q.opts.map((o,i)=>({label: String.fromCharCode(65+i), text:o.text}));
    }
    // if no options detected but a line contains "A." inline, try inline split
    if (!q.opts.length) {
      const inline = q.q.split(/\s+(A\.|B\.|C\.|D\.)\s+/i).filter(Boolean);
      if (inline.length>=2) {
        // inline[0] is question text, rest are options fragments
        q.q = inline[0].trim();
        const rest = q.q ? q.q : '';
      }
    }
  });
  return qs;
}

async function runOCRFromFile(file) {
  statusEl.textContent = 'Loading image...';
  const img = new Image();
  const dataUrl = await new Promise(res=>{
    const fr = new FileReader();
    fr.onload = e=>res(e.target.result);
    fr.readAsDataURL(file);
  });
  img.src = dataUrl;
  await new Promise(r => img.onload = r);

  // preprocess
  preprocessImage(img);
  statusEl.textContent = 'Running OCR (Tesseract)...';
  const { data } = await Tesseract.recognize(canvas, 'eng', {
    logger: m => {
      if (m.status && m.progress) {
        statusEl.textContent = `OCR: ${m.status} ${(m.progress*100).toFixed(0)}%`;
      }
    }
  });
  statusEl.textContent = 'OCR complete';
  return data.text;
}

function renderQuiz(parsed) {
  quizDiv.innerHTML = '';
  if (!parsed.length) { quizDiv.innerHTML = '<div class="small">Koi question detect nahi hua.</div>'; return; }
  parsed.forEach((q,i)=>{
    const div = document.createElement('div'); div.className='question';
    const title = document.createElement('div');
    title.innerHTML = `<strong>Q${q.num ?? (i+1)}:</strong> ${escapeHtml(q.q)}`;
    div.appendChild(title);
    const optsDiv = document.createElement('div'); optsDiv.className='opts';
    // radio buttons to select correct answer
    q.opts.forEach((o,oi)=>{
      const id = `q${i}_opt${oi}`;
      const label = document.createElement('label');
      label.innerHTML = `<input type="radio" name="q${i}" value="${o.label}"> <strong>${o.label}.</strong> ${escapeHtml(o.text)}`;
      optsDiv.appendChild(label);
    });
    // if no options, allow manual add
    if (!q.opts.length) {
      const addBtn = document.createElement('button');
      addBtn.textContent = 'Add option';
      addBtn.onclick = ()=>{
        const t = prompt('Option text');
        if (t) {
          const newLabel = String.fromCharCode(65 + q.opts.length);
          q.opts.push({label:newLabel, text:t});
          renderQuiz(parsed);
        }
      };
      optsDiv.appendChild(addBtn);
    }
    div.appendChild(optsDiv);

    // Save answer button per question
    const saveRow = document.createElement('div'); saveRow.style.marginTop='8px';
    const correctSpan = document.createElement('span'); correctSpan.className='small';
    saveRow.appendChild(correctSpan);
    const saveBtn = document.createElement('button'); saveBtn.textContent='Set correct answer';
    saveBtn.style.marginLeft='8px';
    saveBtn.onclick = ()=>{
      const selected = document.querySelector(`input[name="q${i}"]:checked`);
      if (!selected) { alert('Pehele option select karo'); return; }
      q.correct = selected.value;
      correctSpan.textContent = `Correct: ${q.correct}`;
    };
    saveRow.appendChild(saveBtn);

    // Edit question / options
    const editBtn = document.createElement('button'); editBtn.textContent='Edit Q'; editBtn.style.marginLeft='8px';
    editBtn.onclick = ()=>{
      const newQ = prompt('Edit question text', q.q);
      if (newQ!=null) { q.q = newQ.trim(); renderQuiz(parsed); }
    };
    saveRow.appendChild(editBtn);

    div.appendChild(saveRow);

    quizDiv.appendChild(div);
  });
}

function escapeHtml(s){ return s.replace(/[&<>"]/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;' }[c])); }

runBtn.onclick = async ()=>{
  if (!fileIn.files.length) { alert('Upload an image first'); return; }
  const file = fileIn.files[0];
  try {
    const text = await runOCRFromFile(file);
    ocrtextPre.textContent = text;
    const parsed = simpleParse(text);
    // If parser found no numbered questions, also try naive split by lines with '?' and next lines as options
    if (!parsed.length) {
      // fallback simple grouping: find lines with '?' as question end
      const lines = text.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
      const fallback = [];
      for (let i=0;i<lines.length;i++){
        if (lines[i].endsWith('?')) {
          const qtext = lines[i];
          const opts = [];
          for (let j=i+1;j<Math.min(lines.length,i+6);j++){
            if (/^[A-D][\.\)]/i.test(lines[j]) || /^[A-D]\b/i.test(lines[j])) opts.push({label: String.fromCharCode(65+opts.length), text: lines[j]});
            else if (opts.length) { opts[opts.length-1].text += ' '+lines[j]; }
            else break;
          }
          fallback.push({num:null,q:qtext,opts});
        }
      }
      if (fallback.length) parsed.push(...fallback);
    }
    renderQuiz(parsed);
  } catch (e) {
    console.error(e);
    alert('Error: ' + e.message);
  }
};

exportBtn.onclick = ()=>{
  // collect data
  const questions = Array.from(quizDiv.querySelectorAll('.question')).map((div,i)=>{
    const q = {}; const strong = div.querySelector('strong');
    q.q = div.querySelector('div').textContent.replace(/^Q\d+:/,'').trim();
    q.opts = Array.from(div.querySelectorAll('.opts label')).map(lbl=>{
      const txt = lbl.textContent.trim();
      const m = txt.match(/^([A-D])\.\s*(.+)/i);
      if (m) return {label:m[1], text:m[2].trim()};
      return {label:null, text: txt};
    });
    const corr = div.querySelector('.small')?.textContent?.replace('Correct:','').trim() || null;
    q.correct = corr || null;
    return q;
  });
  const blob = new Blob([JSON.stringify(questions, null, 2)],{type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'quiz.json'; a.click();
  URL.revokeObjectURL(url);
};
</script>
</body>
</html>
